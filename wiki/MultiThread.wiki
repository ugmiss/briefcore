#summary 多线程，线程安全集合，锁，快照
#labels lock,Interlocked,ConcurrentDictionary
===线程安全===
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的
{{{
抛出异常InvalidOperationException：“集合已修改；可能无法执行枚举”
}}}
线程安全问题都是由全局变量及静态变量引起的

若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时对一个变量执行读写操作，一般都需要考虑线程同步，否则就可能影响线程安全

===lock===
lock 确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放

=== Interlocked===
为多线程共享变量提供原子操作
{{{
int i = 0 ;
System.Threading.Interlocked.Increment( ref i);
Console.WriteLine(i);
System.Threading.Interlocked.Decrement( ref i);
Console.WriteLine(i);
System.Threading.Interlocked.Exchange( ref i, 100 );
Console.WriteLine(i);
System.Threading.Interlocked.CompareExchange( ref i, 10 , 100 );
}}}
===Monitor===
{{{
lock (x)
{
DoSomething();
} 

等效于

object obj = ( object )x;
System.Threading.Monitor.Enter(obj);
try 
{
DoSomething();
}
finally 
{
System.Threading.Monitor.Exit(obj);
}
}}}
===System.Collections.Concurrent;===
||`BlockingCollection<T>`||为实现 IProducerConsumerCollection<(Of <(T>)>) 的线程安全集合提供阻止和限制功能|| 
||`ConcurrentBag<T>`|| 表示对象的线程安全的无序集合|| 
||`ConcurrentDictionary<key,value>`||表示可由多个线程同时访问的键值对的线程安全集合|| 
||`ConcurrentQueue<T>`||表示线程安全的先进先出 (FIFO) 集合|| 
||`ConcurrentStack<T>`|| 表示线程安全的后进先出 (LIFO) 集合|| 
||`OrderablePartitioner<T>`||表示将一个可排序数据源拆分成多个分区的特定方式|| 
||`Partitioner`||提供针对数组、列表和可枚举项的常见分区策略|| 
||`Partitioner<T>`|| 表示将一个数据源拆分成多个分区的特定方式||
[http://www.cnblogs.com/kain/archive/2010/08/10/1796524.html]
===Task===
===Parrellel===