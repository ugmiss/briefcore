#summary Prism 可重用，扩展性，灵活性的WPF框架。
#labels Prism,MVVM,MEF,Unity,Bootstrapper,Modules
[http://i.msdn.microsoft.com/dynimg/IC448610.png]
== Modules==
模块，多模块共同组成模块化系统的程序。
Module是一些逻辑上相关的程序集或者资源文件的集合，在Silverlight程序中通常以xap文件为单位存在。而每一个Module中都需要有一个负责进行初始化工作以及与系统进行集成的角色，它需要实现IModule接口。IModule接口中只有一个Initialize方法，一方面这个接口将这个工程标记为一个Module，另一方面你可以在Initialize方法中实现一些逻辑，比如向容器中注册一些Service，或者将视图集成到程序中等等。
====使用Unity方式====
{{{
using System;
using Microsoft.Practices.Prism.Modularity;
using Microsoft.Practices.Prism.Regions;
using Microsoft.Practices.Unity;
using Model;

namespace UserManageModule
{
    [Module(ModuleName = ModuleNames.UserManageModule, OnDemand = true)]
    public class UserManageModule : IModule
    {
        private readonly IRegionManager regionManager;
        public IUnityContainer container { get; set; }
        public UserManageModule(IRegionManager regionManager, IUnityContainer container)
        {
            this.regionManager = regionManager;
            this.container = container;
        }
        public void Initialize()
        {
            regionManager.RegisterViewWithRegion("MainRegion", typeof(UserInfoView));
            //IRegion mainRegion = this.regionManager.Regions["MainRegion"];
            //mainRegion.Add(new UserInfoView());
        }
    }
}
}}}
 
== ModuleInfo==
在创建了一个Module之后，需要通知Prism这个Module的存在，也就是要注册一下。在Prism中，Module是以ModuleInfo的形式存在的。ModuleInfo记录了Module的信息，ModuleName属性是Module的标识符，相当于Module的ID；ModuleType是Module的AssemblyQualifiedName；DependsOn属性是该Module依赖的其它Module的ModuleName的集合，在加载该Module时，如果有依赖项没有加载的话，会先将依赖项加载；InitializationMode，有两种情况——WhenAvailable和OnDemand，当选择了WhenAvailable时，该Module会在程序启动时自动加载，如果选择了OnDemand，则会按需加载，默认情况下是WhenAvailable；Ref，存储该Module的位置，如XXX.xap；State，定义了Module从注册到加载到初始化的整个过程中的状态。
 
== ModuleCatalog==
ModuleCatalog实现了IModuleCatalog接口，它是ModuleInfo的容器，保存着系统中所有Module的信息，不仅会管理哪些Module需要加载，什么时候加载以什么顺序加载等问题，还要检查各个Module之间是否存在着循环依赖、是否有重复的Module等等。ModuleCatalog提供了含参构造方法和AddModule方法，可以通过代码将Module注册进去，同时也可以在xaml文件中配置好Module，然后通过ModuleCatalog.CreateFromXaml方法来加载。
 
== ModuleManager==
ModuleManager实现了IModuleManager接口。顾名思义就是管理Module的类。IModuleManager中含有两个方法和两个事件：Run方法会将所有InitializationMode为WhenAvailable的Module加载，然后进行初始化，初始化的工作委托给了IModuleInitializer来完成，它会获取到Module类(上面提到的实现了IModule接口的类)的实例，然后调用其Initialize方法。LoadModule方法用来加载InitializationMode为OnDemand的Module。两个事件分别用来通知下载Module的进度变化以及Module加载完成。
====按名称手动加载====
{{{
this.moduleManager.LoadModule(ModuleNames.UserManageModule);
}}}
== Shell==
宿主程序
== Region==
== RegionManager==
== Views==
前端UI展现
== ViewModel或Presenters==
ViewModel对控件的属性，命令，事件进行封装。
== Model==
Model封装数据
== Commands==
命令，方法
== Controllers==

== Bootstrapper ==
框架会在这里进行初始化，处理相关配置信息等 
Prism提供了一个抽象基类Bootstrapper，这个类里面包含了包含了许多空的虚方法，可以重写它们添加自己的逻辑。Prism默认提供了两个基于特定容器的Bootstrapper——`UnityBootstrapper`和`MefBootstrapper`，分别使用Unity和Mef来实现依赖注入。
{{{
using System.Windows;
using DevExpress.Xpf.Core;
using Microsoft.Practices.Prism.Modularity;
using Microsoft.Practices.Prism.UnityExtensions;
using Microsoft.Practices.Unity;
namespace ApplicationHost
{
    // 应用程序启动引导
    public class AppBootstrapper : UnityBootstrapper
    {
        // 1.创建模块目录
        protected override IModuleCatalog CreateModuleCatalog()
        {
            return new AggregateModuleCatalog();
        }
        // 2.配置模块目录
        protected override void ConfigureModuleCatalog()
        {
            // 直接注册方式
            // Type moduleAType = typeof(UserManageModule.UserManageModule);
            // ModuleCatalog.AddModule(new ModuleInfo(moduleAType.Name, moduleAType.AssemblyQualifiedName));
            // 物理目录方式 加载模块
            DirectoryModuleCatalog directoryCatalog = new DirectoryModuleCatalog() { ModulePath = @".\DirectoryModules" };
            ((AggregateModuleCatalog)ModuleCatalog).AddCatalog(directoryCatalog);
            // 配置文件方式 加载模块
            ConfigurationModuleCatalog configurationCatalog = new ConfigurationModuleCatalog();
            ((AggregateModuleCatalog)ModuleCatalog).AddCatalog(configurationCatalog);

        }
        // 3.创建Unity IOC容器
        protected override IUnityContainer CreateContainer()
        {
            return base.CreateContainer();
        }
        // 4.配置容器
        protected override void ConfigureContainer()
        {
            base.ConfigureContainer();
        }
        // 5.创建程序Shell
        protected override DependencyObject CreateShell()
        {
            // Resolve解析
            return this.Container.Resolve<Shell>();
        }
        // .初始化Shell
        protected override void InitializeShell()
        {
            base.InitializeShell();
            ThemeManager.ApplicationThemeName = Theme.MetropolisDark.Name;
            App.Current.MainWindow = (Window)this.Shell;
            App.Current.MainWindow.Width = 1300.0;
            App.Current.MainWindow.Height = 730.0;
            //App.Current.MainWindow.MinWidth = 1000.0;
            //App.Current.MainWindow.MinHeight = 600.0;
            App.Current.MainWindow.Show();
        }
    }
}
}}}

===msdn===
Modules. Modules are packages of functionality that can be independently developed, tested, and (optionally) deployed. In many situations, modules are developed and maintained by separate teams. A typical Prism application is built from multiple modules. Modules can be used to represent specific business-related functionality (for example, profile management) and encapsulate all the views, services, and data models required to implement that functionality. Modules can also be used to encapsulate common application infrastructure or services (for example, logging and exception management services) that can be reused across multiple applications.
Module catalog. In a composite application, modules must be discovered and loaded at run time by the host application. In Prism, a module catalog is used to specify which modules to are to be loaded, when they are loaded, and in what order. The module catalog is used by the ModuleManager and ModuleLoader components, which are responsible for downloading the modules if they are remote, loading the module's assemblies into the application domain, and for initializing the module. Prism allows the module catalog to be specified in different ways, including programmatically using code, declaratively using XAML, or using a configuration file. You can also implement a custom module catalog if you need to.
Shell. The shell is the host application into which modules are loaded. The shell defines the overall layout and structure of the application, but it is typically unaware of the exact modules that it will host. It usually implements common application services and infrastructure, but most of the application's functionality and content is implemented within the modules. The shell also provides the top-level window or visual element that will then host the different UI components provided by the loaded modules.
Views. Views are UI controls that encapsulate the UI for a particular feature or functional area of the application. Views are used in conjunction with the MVVM or Model-View-Presenter (MVP) patterns, which are used to provide a clean separation of concerns between the UI and the application's presentation logic and data. Views are used to encapsulate the UI and define user interaction behavior, thereby allowing the view to be updated or replaced independently of the underlying application functionality. Views use data binding to interact with view model and presenter classes.
View models and presenters. View models are classes that encapsulate the application's presentation logic and state. They are part of the MVVM pattern. View models encapsulate much of the application's functionality. Presenters are similar to view models in that they encapsulate the presentation logic and state. They are used as part of the MVP pattern. Both view models and presenters define properties, commands, and events, to which controls in the view can data-bind.
Models. Model classes encapsulate the application data and business logic. They are used as part of the MVVM or MVP patterns. Models encapsulate data and any associated validation and business rules to ensure data consistency and integrity.
Commands. Commands are used to encapsulate application functionality in a way that allows them to be defined and tested independently of the application's UI. They can be defined as command objects or as command methods in the view model or presenter. Prism provides the DelegateCommand class and the CompositeCommand class. The latter is used to represent a collection of commands which are all invoked together.
Regions. Regions are logical placeholders defined within the application's UI (in the shell or within views) into which views are displayed. Regions allow the layout of the application's UI to be updated without requiring changes to the application logic. Many common controls can be used as a region, allowing views to be automatically displayed within controls, such as a ContentControl, ItemsControl, ListBox, or TabControl. Views can be displayed within a region programmatically or automatically. Prism also provides support for implementing navigation with regions. Regions can be located by other components through the RegionManager component, which uses RegionAdapter and RegionBehavior components to coordinate the display of views within specific regions.
Navigation. Navigation is defined as the process by which the application coordinates changes to its UI as a result of the user's interaction with the application or internal application state changes. Prism supports two styles of navigation: state-based navigation, where the state of an existing view is updated to implement simple navigation scenarios, and view-switching navigation, where new views are created and old views replaced within the application's UI. View-switching navigation uses a Uniform Resource Identifier (URI)–based navigation mechanism in conjunction with Prism regions to allow flexible navigation schemes to be implemented.
EventAggregator. Components in a composite application often need to communicate with other components and services in the application in a loosely coupled way. To support this, Prism provides the EventAggregator component, which implements a pub-sub event mechanism, thereby allowing components to publish events and other components to subscribe to those events without either of them requiring a reference to the other. The EventAggregator is often used to allow components defined in different modules to communicate with each other.
Dependency injection container. The Dependency Injection (DI) pattern is used throughout Prism to allow the dependencies between components to be managed. Dependency injection allows component dependencies to be fulfilled at run time, and it supports extensibility and testability. Prism is designed to work with Unity or MEF, or with any other dependency injection containers via the ServiceLocator.
Services. Services are components that encapsulate non-UI related functionality, such as logging, exception management, and data access. Services can be defined by the application or within a module. Services are often registered with the dependency injection container so that they can be located or constructed as required and used by other components that depend on them. 
Controllers. Controllers are classes that are used to coordinate the construction and initialization of views that are to be displayed in a region within the application's UI. Controllers encapsulate the presentation logic that determines which views are to be displayed. The controller will use Prism's view-switching navigation mechanism, which provides an extensible URI-based navigation mechanism to coordinate the construction and placement of views within regions. The Application Controller pattern defines an abstraction that maps to this responsibility.
Bootstrapper. The Bootstrapper component is used by the application to initialize the various Prism components and services. It is used to initialize the dependency injection container to register any application-level components and services with it. It is also used to configure and initialize the module catalog and the shell's view and view model or presenter.
Multi-targeting. Prism supports the development of applications that can target both WPF and Silverlight. By adopting a separated presentation pattern, such as the MVVM or MVP patterns, you can separate the UI of your application from its presentation and business logic. View model, presenter, and model classes can be reused in both WPF and Silverlight versions of the same application. WPF-specific and Silverlight-specific views can then be defined in a way that encapsulates the UI for each.

     